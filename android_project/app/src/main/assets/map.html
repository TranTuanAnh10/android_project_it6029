<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Realtime Delivery Map</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>

    <style>
        /* CSS cho Map */
        html, body, #map {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
        }
        #map {
            position: absolute;
            top: 0; left: 0;
            right: 0; bottom: 0;
        }

        /* CSS cho Loading Spinner ƒë√£ ƒë∆∞·ª£c di chuy·ªÉn sang g√≥c tr√™n b√™n ph·∫£i */
        #loader {
            position: absolute;
            top: 20px; /* V·ªã tr√≠ c√°ch m√©p tr√™n 20px */
            right: 20px; /* V·ªã tr√≠ c√°ch m√©p ph·∫£i 20px */
            z-index: 1000; /* ƒê·∫£m b·∫£o n·∫±m tr√™n map */
            border: 6px solid #f3f3f3;
            border-top: 6px solid #FF3B30; /* M√†u ƒë·ªè n·ªïi b·∫≠t */
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            padding: 2px;
        }

        .hidden {
            display: none !important;
        }

        /* ƒê√£ lo·∫°i b·ªè translate trong keyframes v√¨ loader kh√¥ng c√≤n ·ªü gi·ªØa m√†n h√¨nh */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
<div id="map"></div>
<div id="loader" class="hidden"></div>

<script>
    // --- Kh·ªüi t·∫°o c√°c bi·∫øn to√†n c·ª•c ---
    var map = null;
    var shipperMarker = null;
    var storeMarker = null;
    var receiverMarker = null;
    var routeLine = null;
    var locations = { store: null, receiver: null };
    var currentStatus = "prepared";

    // --- H√†m hi·ªÉn th·ªã/·∫©n Loading Spinner ---
    function showLoader() {
        document.getElementById('loader').classList.remove('hidden');
    }

    function hideLoader() {
        document.getElementById('loader').classList.add('hidden');
    }

    // --- Custom icons (GI·ªÆ NGUY√äN) ---
    var shipIcon = L.icon({
        iconUrl: 'icons/Pin_ship.png',
        iconSize: [32, 36],
        iconAnchor: [16, 36],
    });

    var storeIcon = L.icon({
        iconUrl: 'icons/Pin_shop.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32],
    });

    var userIcon = L.icon({
        iconUrl: 'icons/Pin_user.png',
        iconSize: [32, 32],
        iconAnchor: [16, 32],
    });

    // --- H√†m v·∫Ω tuy·∫øn ƒë∆∞·ªùng ---
    function drawRoute(lat1, lon1, lat2, lon2) {
        if (!map) return;

        // Ki·ªÉm tra kho·∫£ng c√°ch t·ªëi thi·ªÉu tr∆∞·ªõc khi g·ªçi API
        if (Math.abs(lat1 - lat2) < 0.00001 && Math.abs(lon1 - lon2) < 0.00001) {
            console.log("C·∫£nh b√°o: ƒêi·ªÉm b·∫Øt ƒë·∫ßu v√† k·∫øt th√∫c qu√° g·∫ßn, kh√¥ng v·∫Ω tuy·∫øn ƒë∆∞·ªùng.");
            if (routeLine) map.removeLayer(routeLine);
            map.flyTo([lat2, lon2], map.getZoom() > 16 ? map.getZoom() : 16, { duration: 0.5 });
            return;
        }

        var url = `https://router.project-osrm.org/route/v1/driving/${lon1},${lat1};${lon2},${lat2}?overview=full&geometries=geojson`;

        // 1. Hi·ªÉn th·ªã loader tr∆∞·ªõc khi g·ªçi API
        showLoader();

        fetch(url)
            .then(res => res.json())
            .then(data => {
                // 2. ·∫®n loader khi th√†nh c√¥ng
                hideLoader();

                if (data.routes && data.routes.length > 0) {
                    var coords = data.routes[0].geometry.coordinates.map(c => [c[1], c[0]]);

                    // ƒê·∫£m b·∫£o n·ªëi ƒë·∫øn ƒëi·ªÉm ƒë√≠ch
                    const last = coords[coords.length - 1];
                    if (last[0] !== lat2 || last[1] !== lon2) {
                        coords.push([lat2, lon2]);
                    }

                    // Xo√° ƒë∆∞·ªùng c≈©
                    if (routeLine) map.removeLayer(routeLine);

                    // V·∫Ω m·ªõi m√†u ƒë·ªè
                    routeLine = L.polyline(coords, { color: '#FF3B30', weight: 5 }).addTo(map);

                    // Fit to√†n tuy·∫øn
                    map.fitBounds(routeLine.getBounds(), { padding: [50, 50] });
                }
            })
            .catch(err => {
                // 3. ·∫®n loader khi th·∫•t b·∫°i
                hideLoader();
                console.error("L·ªói khi l·∫•y tuy·∫øn ƒë∆∞·ªùng:", err);
            });
    }

    /**
     * H√ÄM CH√çNH: KH·ªûI T·∫†O MAP/MARKER L·∫¶N ƒê·∫¶U HO·∫∂C C·∫¨P NH·∫¨T V·ªä TR√ç SHIPPER
     */
    function initOrUpdateMap(shipperLat, shipperLon, storeLat, storeLon, receiverLat, receiverLon, status) {
        const storePos = [storeLat, storeLon];
        const receiverPos = [receiverLat, receiverLon];
        currentStatus = status;

        // X√°c ƒë·ªãnh xem c√≥ d·ªØ li·ªáu shipper h·ª£p l·ªá hay kh√¥ng.
        const hasShipperData = (shipperLat !== 0 || shipperLon !== 0) && isFinite(shipperLat) && isFinite(shipperLon);

        // --- B∆Ø·ªöC 1: KH·ªûI T·∫†O MAP V√Ä MARKER Tƒ®NH (CH·ªà CH·∫†Y L·∫¶N ƒê·∫¶U) ---
        if (!map) {
            // L∆∞u t·ªça ƒë·ªô tƒ©nh
            locations.store = storePos;
            locations.receiver = receiverPos;

            // V·ªã tr√≠ trung t√¢m ban ƒë·∫ßu: n·∫øu c√≥ shipper th√¨ trung t√¢m l√† shipper, ng∆∞·ª£c l·∫°i l√† c·ª≠a h√†ng
            const initialCenter = hasShipperData ? [shipperLat, shipperLon] : storePos;

            // 1. Kh·ªüi t·∫°o map
            map = L.map('map', {
                zoomControl: false,
                attributionControl: false
            }).setView(initialCenter, 15);

            // 2. N·ªÅn map
            L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
                attribution: '&copy; CartoDB & OpenStreetMap'
            }).addTo(map);

            // 3. T·∫°o Marker tƒ©nh (Store v√† Receiver)
            storeMarker = L.marker(locations.store, { icon: storeIcon, title: "C·ª≠a h√†ng" }).addTo(map);
            receiverMarker = L.marker(locations.receiver, { icon: userIcon, title: "Ng∆∞·ªùi nh·∫≠n" }).addTo(map);

            // 4. T·∫°o Marker Shipper (·∫®n ƒëi n·∫øu ch∆∞a c√≥ data)
            shipperMarker = L.marker([0, 0], {
                icon: shipIcon,
                title: "Shipper",
                opacity: hasShipperData ? 1 : 0
            }).addTo(map);
        }

        // --- B∆Ø·ªöC 2: C·∫¨P NH·∫¨T V·ªä TR√ç V√Ä TUY·∫æN ƒê∆Ø·ªúNG (CH·∫†Y M·ªåI L√öC) ---

        if (hasShipperData) {
            // --- K·ªäCH B·∫¢N A: C√ì DATA SHIPPER ---
            const shipperPos = [shipperLat, shipperLon];

            // 1. C·∫≠p nh·∫≠t v·ªã tr√≠ v√† hi·ªÉn th·ªã Shipper
            shipperMarker.setLatLng(shipperPos);
            shipperMarker.setOpacity(1); // ƒê·∫£m b·∫£o Shipper hi·ªÉn th·ªã

            // 2. C·∫≠p nh·∫≠t tuy·∫øn ƒë∆∞·ªùng d·ª±a tr√™n tr·∫°ng th√°i (Shipper -> Target)
            switch (status) {
                case "prepared":
                case "pickingUp":
                    // üöö T·ª´ shipper ƒë·∫øn c·ª≠a h√†ng
                    const isAtStore = Math.abs(shipperLat - locations.store[0]) < 0.00001 &&
                                     Math.abs(shipperLon - locations.store[1]) < 0.00001;

                    if (!isAtStore) {
                        drawRoute(shipperLat, shipperLon, locations.store[0], locations.store[1]);
                    } else {
                        // Shipper ƒë√£ ƒë·∫øn c·ª≠a h√†ng
                        if (routeLine) map.removeLayer(routeLine);
                        hideLoader(); // ƒê·∫£m b·∫£o ·∫©n loader n·∫øu kh√¥ng g·ªçi API
                        map.flyTo(locations.store, map.getZoom() > 16 ? map.getZoom() : 16, { duration: 0.5 });
                    }
                    break;

                case "delivering":
                    // üöö T·ª´ shipper ƒë·∫øn ng∆∞·ªùi nh·∫≠n
                    const isAtReceiver = Math.abs(shipperLat - locations.receiver[0]) < 0.00001 &&
                                         Math.abs(shipperLon - locations.receiver[1]) < 0.00001;

                    if (!isAtReceiver) {
                        drawRoute(shipperLat, shipperLon, locations.receiver[0], locations.receiver[1]);
                    } else {
                        // Shipper ƒë√£ ƒë·∫øn ng∆∞·ªùi nh·∫≠n
                        if (routeLine) map.removeLayer(routeLine);
                        hideLoader(); // ƒê·∫£m b·∫£o ·∫©n loader n·∫øu kh√¥ng g·ªçi API
                        map.flyTo(locations.receiver, 16, { duration: 0.5 });
                    }
                    break;

                case "finish":
                    if (routeLine) map.removeLayer(routeLine);
                    hideLoader(); // ƒê·∫£m b·∫£o ·∫©n loader khi k·∫øt th√∫c
                    map.flyTo(locations.receiver, 16, { duration: 0.8 });
                    shipperMarker.setOpacity(0); // ·∫®n Shipper khi giao xong
                    return;
            }

            // 3. Zoom m∆∞·ª£t ƒë·∫øn shipper (n·∫øu kh√¥ng ph·∫£i finish)
            if (status !== "finish") {
                 map.flyTo(shipperPos, map.getZoom() > 15 ? map.getZoom() : 15, { duration: 0.5 });
            }

        } else {
            // --- K·ªäCH B·∫¢N B: KH√îNG C√ì DATA SHIPPER (0, 0) ---

            // 1. ·∫®n Shipper Marker
            if (shipperMarker) {
                shipperMarker.setOpacity(0);
            }

            // 2. V·∫Ω tuy·∫øn ƒë∆∞·ªùng c·ªë ƒë·ªãnh C·ª≠a h√†ng -> Ng∆∞·ªùi nh·∫≠n
            if (status !== "finish") {
                drawRoute(locations.store[0], locations.store[1], locations.receiver[0], locations.receiver[1]);
            } else {
                 // N·∫øu finish m√† kh√¥ng c√≥ data shipper (tr∆∞·ªùng h·ª£p hi·∫øm) th√¨ ch·ªâ zoom v√†o ng∆∞·ªùi nh·∫≠n
                 if (routeLine) map.removeLayer(routeLine);
                 hideLoader(); // ƒê·∫£m b·∫£o ·∫©n loader khi k·∫øt th√∫c
                 map.flyTo(locations.receiver, 16, { duration: 0.8 });
            }
        }
    }

    window.initOrUpdateMap = initOrUpdateMap;
</script>
</body>
</html>